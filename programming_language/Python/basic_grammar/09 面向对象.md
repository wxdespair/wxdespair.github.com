## \_\_init\_\_ 方法

\_\_init\_\_ 方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的初始化 。注意，这个名称的开始和结尾都是双下划线。

```python
#!/usr/bin/python
# Filename: class_init.py
class Person:
    def __init__(self, name): # 类似于构造函数 
        self.name = name
    def sayHi(self):
        print 'Hello, my name is', self.name
p = Person('Swaroop')
p.sayHi()
# This short example can also be written as Person('Swaroop').sayHi()
''' 输出
$ python class_init.py
Hello, my name is Swaroop 
'''
```

这里，把\_\_init\_\_ 方法定义为取一个参数name（以及普通的参数self）。在这个\_\_init\_\_里，只是创建一个新的域，也称为name。注意它们是两个不同的变量，尽管它们有相同的名
字。点号能够区分它们。

最重要的是，没有专门调用\_\_init\_\_方法，只是在创建一个类的新实例的时候，把参数包括在圆括号内跟在类名后面，从而传递给\_\_init\_\_方法。这是这种方法的重要之处。

现在，能够在方法中使用self.name域。这在sayHi方法中得到了验证。

## 类与对象的方法

事实上，类与对象的数据部分只是与类和对象的名称空间绑定 的普通变量，即这些名称只在这些类与对象的前提下有效。有两种类型的 域 ——类的变量和对象的变量，它们根据是类还是对象 拥有 这个变量而区分。类的变量 由一个类的所有对象（实例）共享使用。只有一个类变量的拷贝，所以当某个对象对类的变量做了改动的时候，这个改动会反映到所有其他的实例上。对象的变量 由类的每个对象/实例拥有。因此每个对象有自己对这个域的一份拷贝，即它们不是共享的，在同一个类的不同实例中，虽然对象的变量有相同的名称，但是是互不相关的。

Python中所有的类成员（包括数据成员）都是 公共的 ，所有的方法都是 有效的 。只有一个例外：如果你使用的数据成员名称以 双下划线前缀 比如\_\_privatevar，Python的名称管理体系会有效地把它作为私有变量。这样就有一个惯例，如果某个变量只想在类或对象中使用，就应该以单下划线前缀。而其他的名称都将作为公共的，可以被其他类/对象使用。记住这只是一个惯例，并不是Python所要求的（与双下划线前缀不同）。